@page "/downloadPage"
@using System.Net
@attribute [Authorize]
@inject IJSRuntime JS

<h3>Download your File from Cloud</h3>

<script>
    window.doSomething = () => {
        console.log("doSomething");
    };
</script>

@if (userFileNames == null)
{
    <p><em>Loading..</em></p>
}
else
{
    <table class="table">
        <thead>
            <tr>
                <th>File Name</th>
                <th>Upload Date</th>
            </tr>
        </thead>
        <tbody>
            @foreach(var fileData in userFileNames)
            {
                <tr @onmouseover="() => ChangeCursorStyle(true)" @onmouseout="() => ChangeCursorStyle(false)" @onclick="() => DownloadFile(fileData.FileName)" style="@cursorStyle">
                    <td>@fileData.FileName</td>
                    <td>@fileData.UploadDate</td>
                </tr>
            }
        </tbody>
    </table>
}

@code
{
    private string cursorStyle = "";

    private void ChangeCursorStyle(bool isHovered)
    {
        cursorStyle = isHovered ? "cursor: pointer;" : "";
    }
}

@code {
    private List<FilesNameDate>? userFileNames;
    private CryptoService _cryptoService = new CryptoService();
    private string? jwt;

    protected override async Task OnInitializedAsync()
    {
        // jwt = await LocalStorage.GetItemAsync<string>("token");
        // Http.DefaultRequestHeaders.Remove("Authorization");
        // Http.DefaultRequestHeaders.Add("Authorization", "Bearer " + jwt);

        // userFileNames = await Http.GetFromJsonAsync<List<FilesNameDate>?>("api/File/getUploadedFileNamesAndDates");
        await GetFilesNamesAndDatesThroughProxy();
        Console.WriteLine("gata");
    }

    public async Task GetFilesNamesAndDatesThroughProxy()
    {
        jwt = await LocalStorage.GetItemAsync<string>("token");

        try
        {
            HttpClient httpClient = HttpServiceCustom.GetProxyClient();
            httpClient.DefaultRequestHeaders.Remove("Authorization");
            httpClient.DefaultRequestHeaders.Add("Authorization", "Bearer " + jwt);
            userFileNames = await httpClient.GetFromJsonAsync<List<FilesNameDate>?>("getFileNamesAndDates");
        }
        catch(Exception e)
        {
            Console.WriteLine(e.Message);
        }

    }

    public async void DownloadFile(string fileName)
    {
        HttpClient httpClient = HttpServiceCustom.GetProxyClient();
        httpClient.DefaultRequestHeaders.Remove("Authorization");
        httpClient.DefaultRequestHeaders.Add("Authorization", "Bearer " + jwt);

        var response = await httpClient.PostAsJsonAsync("/getFileFromStorage", fileName);
        httpClient.Dispose();
        Console.WriteLine(response.Content.ToString());
        ServerBlobFIle? serverFile = response.Content.ReadFromJsonAsync<ServerBlobFIle>().Result;

        string base64SymKey = await LocalStorage.GetItemAsync<string>("Base64SymKey");
        string base64FileKey = _cryptoService.DecryptString(Convert.FromBase64String(serverFile.FileKey), Convert.FromBase64String(base64SymKey));
        string base64FileIv = _cryptoService.DecryptString(Convert.FromBase64String(serverFile.FileIv), Convert.FromBase64String(base64SymKey));

        if(serverFile != null)
        {
            byte[] fileContent = await _cryptoService.GetDecryptedFile(serverFile.EncBase64File, base64FileKey,base64FileIv);
            string strFile = Encoding.UTF8.GetString(fileContent);
            try
            {
                await JS.InvokeVoidAsync("downloadFile", fileName, fileContent);
            }
            catch(Exception e)
            {
                Console.WriteLine(e.Message);
            }
        Console.WriteLine("aici");
        }
        else
            Console.WriteLine("serverFile is null");
    }
}
